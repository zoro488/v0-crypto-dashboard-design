#!/usr/bin/env python3
"""
ğŸ¤– GITHUB ISSUES & PRS AUTOMATION - CHRONOS SYSTEM
Automatically creates issues and pull requests for detected problems
"""

import os
import sys
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any

try:
    import requests
except ImportError:
    print("ğŸ“¦ Installing requests...")
    os.system("pip install requests")
    import requests

class GitHubAutomation:
    """Automates GitHub Issues and PRs creation"""
    
    def __init__(self):
        self.github_token = os.getenv('GITHUB_TOKEN')
        self.repo_owner = os.getenv('GITHUB_REPOSITORY_OWNER', 'zoro488')
        self.repo_name = os.getenv('GITHUB_REPOSITORY_NAME', 'v0-crypto-dashboard-design')
        
        self.api_base = f"https://api.github.com/repos/{self.repo_owner}/{self.repo_name}"
        self.headers = {
            'Authorization': f'token {self.github_token}' if self.github_token else '',
            'Accept': 'application/vnd.github.v3+json'
        }
        
        self.created_issues = []
        self.created_prs = []
    
    def create_issue(self, title: str, body: str, labels: List[str] = None, assignees: List[str] = None) -> Dict[str, Any]:
        """Create a GitHub issue"""
        
        if not self.github_token:
            print("âš ï¸  No GITHUB_TOKEN set, simulating issue creation")
            issue = {
                'number': len(self.created_issues) + 1,
                'title': title,
                'body': body,
                'labels': labels or [],
                'state': 'open',
                'html_url': f'https://github.com/{self.repo_owner}/{self.repo_name}/issues/simulated'
            }
            self.created_issues.append(issue)
            return issue
        
        url = f"{self.api_base}/issues"
        
        data = {
            'title': title,
            'body': body,
            'labels': labels or [],
            'assignees': assignees or []
        }
        
        try:
            response = requests.post(url, headers=self.headers, json=data)
            
            if response.status_code == 201:
                issue = response.json()
                self.created_issues.append(issue)
                print(f"âœ… Created issue #{issue['number']}: {title}")
                return issue
            else:
                print(f"âŒ Failed to create issue: {response.status_code}")
                print(response.text)
                return None
        except Exception as e:
            print(f"âŒ Error creating issue: {e}")
            return None
    
    def create_issues_from_validation_report(self, report_path: str) -> List[Dict[str, Any]]:
        """Create issues from data validation report"""
        
        if not Path(report_path).exists():
            print(f"âš ï¸  Report not found: {report_path}")
            return []
        
        with open(report_path) as f:
            report = json.load(f)
        
        issues_created = []
        
        # Create issues for CSV validation errors
        if 'validations' in report and 'csv' in report['validations']:
            for csv_result in report['validations']['csv']:
                if csv_result['errors']:
                    title = f"ğŸ› Data Error: {csv_result['file']}"
                    
                    body = f"""## Data Validation Error

**File:** `{csv_result['file']}`

**Errors Found:** {len(csv_result['errors'])}

### Details

"""
                    for error in csv_result['errors'][:10]:  # Limit to first 10 errors
                        body += f"- {error}\n"
                    
                    if len(csv_result['errors']) > 10:
                        body += f"\n... and {len(csv_result['errors']) - 10} more errors\n"
                    
                    body += f"""

### Expected Records
- **Expected:** {csv_result['expected_count']}
- **Found:** {csv_result['record_count']}

### Action Required
1. Review the CSV file
2. Fix validation errors
3. Re-run migration if needed

**Generated by:** Automation System
**Report:** `{report_path}`
"""
                    
                    issue = self.create_issue(
                        title=title,
                        body=body,
                        labels=['bug', 'data-validation', 'automated']
                    )
                    
                    if issue:
                        issues_created.append(issue)
        
        # Create issues for Firestore sync problems
        if 'validations' in report and 'comparisons' in report['validations']:
            for comparison in report['validations']['comparisons']:
                if comparison['sync_status'] == 'out_of_sync':
                    title = f"ğŸ”„ Data Sync Issue: {comparison['collection']}"
                    
                    body = f"""## Data Synchronization Issue

**Collection:** `{comparison['collection']}`
**CSV File:** `{comparison['csv_file']}`

**Status:** Out of Sync

### Differences

"""
                    for diff in comparison['differences']:
                        body += f"- {diff}\n"
                    
                    body += f"""

### Action Required
1. Run data migration: `pnpm migrate:{comparison['collection']}`
2. Verify data integrity
3. Re-run validation

**Generated by:** Automation System
**Report:** `{report_path}`
"""
                    
                    issue = self.create_issue(
                        title=title,
                        body=body,
                        labels=['sync-issue', 'data', 'automated']
                    )
                    
                    if issue:
                        issues_created.append(issue)
        
        return issues_created
    
    def create_issues_from_ui_report(self, report_path: str) -> List[Dict[str, Any]]:
        """Create issues from UI test report"""
        
        if not Path(report_path).exists():
            print(f"âš ï¸  Report not found: {report_path}")
            return []
        
        with open(report_path) as f:
            report = json.load(f)
        
        issues_created = []
        
        # Create issues for failed tests
        if 'tests' in report:
            for test_result in report['tests']:
                if test_result['status'] == 'failed' and test_result['issues']:
                    title = f"ğŸ¨ UI Issue: {test_result['test']}"
                    
                    body = f"""## UI Test Failure

**Test:** `{test_result['test']}`
**Status:** Failed

### Issues Found

"""
                    for issue in test_result['issues']:
                        body += f"- {issue}\n"
                    
                    # Add metrics if available
                    if test_result.get('metrics'):
                        body += "\n### Metrics\n\n"
                        for key, value in test_result['metrics'].items():
                            body += f"- **{key}:** {value}\n"
                    
                    # Add fixes if available
                    if 'fixes' in test_result and test_result['fixes']:
                        body += "\n### Suggested Fixes\n\n"
                        for fix in test_result['fixes']:
                            body += f"""**Component:** `{fix['component']}`
**Issue:** {fix['issue']}
**Fix:** `{fix['fix']}`

"""
                    
                    body += f"""

### Action Required
1. Review the component
2. Apply suggested fixes
3. Re-run UI tests

**Generated by:** Automation System
**Report:** `{report_path}`
"""
                    
                    issue = self.create_issue(
                        title=title,
                        body=body,
                        labels=['ui', 'bug', 'automated']
                    )
                    
                    if issue:
                        issues_created.append(issue)
        
        return issues_created
    
    def create_improvement_issues(self) -> List[Dict[str, Any]]:
        """Create issues for general improvements based on analysis"""
        
        issues_created = []
        
        improvements = [
            {
                'title': 'âš¡ Optimize React Query cache configuration',
                'body': '''## Performance Optimization

### Objective
Fine-tune React Query cache settings for optimal performance

### Current Status
- `staleTime`: 30 seconds
- `gcTime`: 5 minutes

### Proposed Changes
1. Analyze query patterns
2. Adjust staleTime per query type
3. Implement custom cache invalidation
4. Add prefetching for common routes

### Expected Impact
- Further reduce Firestore reads
- Improve perceived performance
- Better user experience

**Priority:** Medium
**Effort:** 2-3 hours
''',
                'labels': ['enhancement', 'performance']
            },
            {
                'title': 'ğŸ§ª Increase test coverage to 90%',
                'body': '''## Test Coverage Improvement

### Objective
Achieve 90% test coverage across the codebase

### Current Coverage
- Unit tests: ~60%
- E2E tests: Basic coverage

### Action Items
1. Add tests for business logic service
2. Test all Zod schemas
3. Add integration tests for Firestore operations
4. Test error boundaries
5. Add tests for all custom hooks

### Files Needing Tests
- `app/lib/services/business-logic.service.ts`
- `app/hooks/useBusinessOperations.ts`
- `app/hooks/useTrazabilidad.ts`
- All panel components

**Priority:** High
**Effort:** 1-2 weeks
''',
                'labels': ['testing', 'quality']
            },
            {
                'title': 'ğŸ“Š Add real-time data sync indicators',
                'body': '''## Feature: Real-time Sync Status

### Objective
Show users when data is syncing with Firestore

### Proposed Implementation
1. Add sync indicator in header
2. Show "Syncing..." during mutations
3. Display "Synced" confirmation
4. Handle offline state gracefully

### Components to Update
- Header
- All forms with mutations
- Dashboard panels

### Technical Approach
- Use React Query `isLoading` and `isFetching` states
- Add custom hook `useSyncStatus`
- Implement optimistic updates

**Priority:** Medium
**Effort:** 3-4 hours
''',
                'labels': ['enhancement', 'ux']
            },
            {
                'title': 'ğŸ”’ Implement field-level Firestore security',
                'body': '''## Security Enhancement

### Objective
Add field-level security rules in Firestore

### Current Status
- Basic authentication checks in place
- Document-level rules implemented

### Proposed Enhancements
1. Add field validation rules
2. Implement role-based field access
3. Add audit logging for sensitive operations
4. Encrypt sensitive data fields

### Fields Requiring Protection
- Bank account details
- Customer payment information
- Distributor pricing
- Financial reports

**Priority:** High
**Effort:** 1 week
''',
                'labels': ['security', 'enhancement']
            },
            {
                'title': 'ğŸ“± Optimize mobile responsiveness',
                'body': '''## Mobile Optimization

### Objective
Improve mobile experience across all viewports

### Issues
1. Some panels overflow on small screens
2. Forms need better mobile layout
3. Canvas visualizations performance on mobile
4. Touch gestures for 3D interactions

### Action Items
1. Audit all components on mobile viewports
2. Implement responsive Bento grid
3. Add mobile-specific touch handlers
4. Optimize canvas rendering for mobile GPUs
5. Add mobile navigation drawer

**Priority:** Medium
**Effort:** 1 week
''',
                'labels': ['mobile', 'responsive', 'ux']
            }
        ]
        
        for improvement in improvements:
            issue = self.create_issue(
                title=improvement['title'],
                body=improvement['body'],
                labels=improvement['labels']
            )
            
            if issue:
                issues_created.append(issue)
        
        return issues_created
    
    def run_automation(self) -> Dict[str, Any]:
        """Run all GitHub automation tasks"""
        print("\n" + "="*80)
        print("ğŸ¤– STARTING GITHUB ISSUES & PRS AUTOMATION")
        print("="*80 + "\n")
        
        all_issues = []
        
        # Find latest reports
        reports_dir = Path(__file__).parent / 'reports'
        
        # Data validation reports
        print("ğŸ“Š Processing data validation reports...")
        data_reports = sorted(reports_dir.glob('data_validation_*.json'))
        if data_reports:
            latest_data_report = data_reports[-1]
            issues = self.create_issues_from_validation_report(str(latest_data_report))
            all_issues.extend(issues)
            print(f"   Created {len(issues)} issues from data validation")
        
        # UI test reports
        print("ğŸ¨ Processing UI test reports...")
        ui_reports_dir = reports_dir / 'ui'
        if ui_reports_dir.exists():
            ui_reports = sorted(ui_reports_dir.glob('ui_test_report_*.json'))
            if ui_reports:
                latest_ui_report = ui_reports[-1]
                issues = self.create_issues_from_ui_report(str(latest_ui_report))
                all_issues.extend(issues)
                print(f"   Created {len(issues)} issues from UI tests")
        
        # Create improvement issues
        print("ğŸ’¡ Creating improvement issues...")
        improvement_issues = self.create_improvement_issues()
        all_issues.extend(improvement_issues)
        print(f"   Created {len(improvement_issues)} improvement issues")
        
        # Generate summary
        print("\n" + "="*80)
        print("ğŸ“Š AUTOMATION SUMMARY")
        print("="*80)
        print(f"âœ… Total issues created: {len(all_issues)}")
        print(f"ğŸ“‹ Issues by type:")
        
        labels_count = {}
        for issue in all_issues:
            for label in issue.get('labels', []):
                if isinstance(label, dict):
                    label_name = label.get('name', 'unknown')
                else:
                    label_name = label
                labels_count[label_name] = labels_count.get(label_name, 0) + 1
        
        for label, count in sorted(labels_count.items()):
            print(f"   - {label}: {count}")
        
        print("\nğŸ“ View issues at:")
        print(f"   https://github.com/{self.repo_owner}/{self.repo_name}/issues")
        print("="*80 + "\n")
        
        return {
            'issues_created': len(all_issues),
            'issues': all_issues
        }

if __name__ == "__main__":
    automation = GitHubAutomation()
    result = automation.run_automation()
    
    print("âœ… GITHUB AUTOMATION COMPLETE!")
    sys.exit(0)
